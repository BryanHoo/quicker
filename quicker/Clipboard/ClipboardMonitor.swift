import Foundation
import OSLog

protocol ClipboardStoreInserting {
    func insert(text: String)
    func insertRTF(rtfData: Data, plainText: String, contentHash: String)
    func insertImage(pngData: Data, contentHash: String)
}

struct ClipboardMonitorLogic {
    let ignoreAppStore: IgnoreAppStore
    let clipboardStore: ClipboardStoreInserting

    func handleCapturedChange(_ captured: CapturedClipboardContent, frontmostBundleId: String?) {
        guard ignoreAppStore.isIgnored(bundleIdentifier: frontmostBundleId) == false else { return }

        switch captured.kind {
        case .text:
            clipboardStore.insert(text: captured.plainText)
        case .rtf:
            if let rtf = captured.rtfData {
                clipboardStore.insertRTF(rtfData: rtf, plainText: captured.plainText, contentHash: captured.contentHash)
            } else {
                clipboardStore.insert(text: captured.plainText)
            }
        case .image:
            if let png = captured.pngData {
                clipboardStore.insertImage(pngData: png, contentHash: captured.contentHash)
            }
        }
    }
}

final class ClipboardMonitor {
    private let logger = Logger(subsystem: "quicker", category: "ClipboardMonitor")

    private let pasteboard: PasteboardClient
    private let frontmostAppProvider: FrontmostAppProviding
    private let logic: ClipboardMonitorLogic

    private var lastChangeCount: Int
    private var timer: Timer?

    init(
        pasteboard: PasteboardClient,
        frontmostAppProvider: FrontmostAppProviding,
        logic: ClipboardMonitorLogic
    ) {
        self.pasteboard = pasteboard
        self.frontmostAppProvider = frontmostAppProvider
        self.logic = logic
        self.lastChangeCount = pasteboard.changeCount
    }

    func start(pollInterval: TimeInterval = 0.3) {
        stop()
        logger.info("start(pollInterval: \(pollInterval, privacy: .public)) initialChangeCount=\(self.lastChangeCount, privacy: .public)")
        timer = Timer.scheduledTimer(withTimeInterval: pollInterval, repeats: true) { [weak self] _ in
            self?.pollOnce()
        }
        timer?.tolerance = pollInterval * 0.15
    }

    func stop() {
        timer?.invalidate()
        timer = nil
    }

    func pollOnce() {
        let current = pasteboard.changeCount
        let previous = lastChangeCount
        guard current != previous else { return }
        lastChangeCount = current

        logger.debug("pasteboard changeCount changed: \(current, privacy: .public) (was: \(previous, privacy: .public))")

        guard let snapshot = pasteboard.readSnapshot() else {
            logger.info("pasteboard.readSnapshot() returned nil for changeCount=\(current, privacy: .public)")
            return
        }

        guard let captured = PasteboardCaptureLogic().capture(snapshot: snapshot) else {
            let markerTypeIdentifiers: Set<String> = [
                "org.nspasteboard.TransientType",
                "org.nspasteboard.ConcealedType",
                "org.nspasteboard.AutoGeneratedType",
                "com.agilebits.onepassword",
                "de.petermaurer.TransientPasteboardType",
            ]
            let hasMarker = snapshot.items.contains { item in
                item.typeIdentifiers.contains(where: markerTypeIdentifiers.contains)
            }
            let pngBytes = snapshot.items.first(where: { $0.pngData != nil })?.pngData?.count ?? 0
            let tiffBytes = snapshot.items.first(where: { $0.tiffData != nil })?.tiffData?.count ?? 0
            let rtfBytes = snapshot.items.first(where: { $0.rtfData != nil })?.rtfData?.count ?? 0
            let stringCount = snapshot.items.compactMap(\.string).count
            logger.info("PasteboardCaptureLogic.capture() returned nil items=\(snapshot.items.count, privacy: .public) hasMarker=\(hasMarker, privacy: .public) pngBytes=\(pngBytes, privacy: .public) tiffBytes=\(tiffBytes, privacy: .public) rtfBytes=\(rtfBytes, privacy: .public) stringCount=\(stringCount, privacy: .public)")
            return
        }
        let frontmostBundleId = frontmostAppProvider.frontmostBundleIdentifier
        logger.debug("captured kind=\(captured.kind.rawValue, privacy: .public) items=\(snapshot.items.count, privacy: .public) frontmost=\(frontmostBundleId ?? "nil", privacy: .public)")
        logic.handleCapturedChange(captured, frontmostBundleId: frontmostBundleId)
    }
}
